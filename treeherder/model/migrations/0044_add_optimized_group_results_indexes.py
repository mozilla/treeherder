# Generated by Django for Treeherder group_results performance optimization
# Optimized indexes specifically for the Django ORM query path used by get_group_results

from django.db import migrations


class Migration(migrations.Migration):
    # Disable atomic transactions for CONCURRENT index creation
    atomic = False

    dependencies = [
        ('model', '0043_alter_referencedatasignatures_job_group_name'),
    ]

    operations = [
        # 1. MOST CRITICAL: Covering index for the Group table with name included
        # This eliminates separate lookups for the group name in the values_list query
        migrations.RunSQL(
            sql='CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_group_push_lookup ON "group"(id) INCLUDE (name);',
            reverse_sql='DROP INDEX IF EXISTS idx_group_push_lookup;'
        ),

        # 2. Optimize the job_logs → job → push join path (the main bottleneck)
        # This handles the job__push__revision and job__push__repository filters efficiently
        migrations.RunSQL(
            sql="CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_job_push_repo_composite ON job(push_id, repository_id) INCLUDE (id);",
            reverse_sql="DROP INDEX IF EXISTS idx_job_push_repo_composite;"
        ),

        # 3. Critical: Partial index for group_status filtering
        # Only indexes OK and ERROR status (1, 2) which are the only ones the query needs
        migrations.RunSQL(
            sql="CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_group_status_optimized ON group_status(group_id, status) WHERE status IN (1, 2);",
            reverse_sql="DROP INDEX IF EXISTS idx_group_status_optimized;"
        ),

        # 4. Support the taskcluster_metadata lookup with covering index
        # Includes task_id to avoid separate table lookups for the values_list query
        migrations.RunSQL(
            sql="CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_taskcluster_metadata_covering ON taskcluster_metadata(job_id) INCLUDE (task_id);",
            reverse_sql="DROP INDEX IF EXISTS idx_taskcluster_metadata_covering;"
        ),

        # 5. Better push lookup index with covering id
        # Optimizes the initial Push.objects.get() call and includes id for joins
        migrations.RunSQL(
            sql="CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_push_revision_repo_covering ON push(revision, repository_id) INCLUDE (id);",
            reverse_sql="DROP INDEX IF EXISTS idx_push_revision_repo_covering;"
        ),

        # 6. Optimize the job_logs join specifically
        # This handles the Group → job_logs relationship efficiently
        migrations.RunSQL(
            sql="CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_job_log_job_id_optimized ON job_log(job_id) INCLUDE (id);",
            reverse_sql="DROP INDEX IF EXISTS idx_job_log_job_id_optimized;"
        ),
    ]
