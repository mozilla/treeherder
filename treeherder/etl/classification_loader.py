import logging
import re

import environ
import newrelic.agent

from treeherder.model.models import (
    BugJobMap,
    Bugscache,
    FailureClassification,
    Job,
    JobNote,
    MozciClassification,
    Push,
    Repository,
)
from treeherder.utils.taskcluster import download_artifact, get_task_definition

env = environ.Env()
logger = logging.getLogger(__name__)

CLASSIFICATION_PRODUCTION_ROUTE_REGEX = re.compile(
    r"index\.project\.mozci\.classification\.(.+)\.revision\.([0-9A-Fa-f]+)"
)
CLASSIFICATION_TESTING_ROUTE_REGEX = re.compile(
    r"index\.project\.mozci\.testing\.classification\.(.+)\.revision\.([0-9A-Fa-f]+)"
)


class ClassificationLoader:
    def process(self, pulse_job, root_url):
        task_id = pulse_job["status"]["taskId"]

        task_definition = get_task_definition(root_url, task_id)
        assert (
            "routes" in task_definition and len(task_definition["routes"]) > 0
        ), "A route containing the push project and revision is needed to save the mozci classification"
        # Retrieving a Push object thanks to the project/revision parsed from the task first route
        try:
            push = self.get_push(task_definition["routes"][0])
        except Repository.DoesNotExist:
            return
        except (AttributeError, Push.DoesNotExist):
            logger.error(
                "Failed to retrieve the Push that was classified by mozci during task %s", task_id
            )
            # Raising the exception to retry the Celery task as much as possible
            raise

        # Downloading the artifact containing the classification generated by mozci for this push
        classification_json = download_artifact(root_url, task_id, "public/classification.json")

        # Saving the mozci classification in the database
        results = dict(MozciClassification.CLASSIFICATION_RESULT)
        classification = classification_json["push"]["classification"]
        assert (
            classification in results.keys()
        ), "Classification result should be a value in BAD, GOOD, UNKNOWN"

        logger.info(
            "Storing mozci classification calculated as %s for push %s on repository %s",
            classification,
            push.revision,
            push.repository.name,
        )
        MozciClassification.objects.create(
            push=push,
            result=classification,
            task_id=task_id,
        )

        try:
            autoclassified_intermittent = FailureClassification.objects.get(
                name="autoclassified intermittent"
            )
        except FailureClassification.DoesNotExist:
            logger.error(
                "FailureClassification named 'autoclassified intermittent' does not exist."
            )
            raise

        # Autoclassifying intermittent failures when the "autoclassify" flag is activated on them
        self.autoclassify_failures(
            classification_json["failures"]["intermittent"], autoclassified_intermittent
        )

    def get_push(self, task_route):
        mozci_env = env('PULSE_MOZCI_ENVIRONMENT', default='production')
        if mozci_env == 'testing':
            route_regex = CLASSIFICATION_TESTING_ROUTE_REGEX
        else:
            if mozci_env != 'production':
                logger.warning(
                    f'PULSE_MOZCI_ENVIRONMENT should be testing or production not {mozci_env}, defaulting to production'
                )
            route_regex = CLASSIFICATION_PRODUCTION_ROUTE_REGEX

        try:
            project, revision = route_regex.search(task_route).groups()
        except AttributeError as e:
            logger.error(
                "Failed to parse the given route '%s' to retrieve the push project and revision: %s",
                task_route,
                e,
            )
            raise

        try:
            newrelic.agent.add_custom_attribute("project", project)

            repository = Repository.objects.get(name=project)
        except Repository.DoesNotExist:
            logger.info("Job with unsupported project: %s", project)
            raise

        try:
            newrelic.agent.add_custom_attribute("revision", revision)

            revision_field = 'revision__startswith' if len(revision) < 40 else 'revision'
            filter_kwargs = {'repository': repository, revision_field: revision}

            push = Push.objects.get(**filter_kwargs)
        except Push.DoesNotExist:
            logger.info("Job with unsupported revision: %s", revision)
            raise

        return push

    def autoclassify_failures(self, failures, classification):
        for tasks in failures.values():
            for task in tasks:
                # Keeping only the tasks that should be autoclassified
                if not task.get("autoclassify"):
                    continue

                bugs = []
                for failing_test_name in task.get("tests", []):
                    try:
                        bugs.append(
                            Bugscache.objects.get(
                                summary__endswith=f"{failing_test_name} | single tracking bug"
                            )
                        )
                    except Bugscache.DoesNotExist:
                        logger.info(
                            "No single tracking Bugzilla bug found for test name: %s",
                            failing_test_name,
                        )

                if not bugs:
                    # No associated Bugzilla bug exists, skipping the autoclassification
                    continue

                # Retrieving the relevant Job
                try:
                    job = Job.objects.get(taskcluster_metadata__task_id=task["task_id"])
                except Job.DoesNotExist:
                    logger.error(
                        "Job associated to the TC task %s does not exist and could not be autoclassified.",
                        task["task_id"],
                    )
                    raise

                # Skipping it if it was already classified either by Sheriffs or by mozci
                if JobNote.objects.filter(job=job).exists():
                    logger.info("Job %s is already associated to a JobNote.", job)
                    continue

                # Adding an "autoclassified intermittent" classification on it
                JobNote.objects.create(
                    job=job,
                    failure_classification=classification,
                    text="Autoclassified by mozci bot as an intermittent failure",
                )

                # Linking it to the relevant Bugzilla single tracking bugs
                BugJobMap.objects.bulk_create(
                    [BugJobMap(job=job, bug_id=bug.id) for bug in bugs], ignore_conflicts=True
                )
